package dev.fritz2.lenses

import com.google.devtools.ksp.*
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.KotlinPoetKspPreview
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo

class LensesProcessor(
    private val options: Map<String, String>,
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val lensesAnnotated = resolver.getSymbolsWithAnnotation(Lenses::class.qualifiedName!!)
        val unableToProcess = lensesAnnotated.filterNot { it.validate() }

        /*
        logger.warn("Hello")
        logger.warn(symbols.joinToString("; "))

         */

        lensesAnnotated.filter { it is KSClassDeclaration && it.validate() }
            .forEach { it.accept(LensesVisitor(), Unit) }

        return unableToProcess.toList()
    }

    private inner class LensesVisitor : KSVisitorVoid() {
        @OptIn(KotlinPoetKspPreview::class)
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            /*
            1.) Is data class
            2.) Has companion with @WithLenses
            yes -> new way
            no -> old way
             */
            val packageName = classDeclaration.packageName.asString()

            if (classDeclaration.isDataClass()) {
                val compObj = classDeclaration.declarations
                    .filterIsInstance<KSClassDeclaration>()
                    .filter { it.isCompanionObject }
                    .firstOrNull()

                /*

 && compObj.annotations.map { it.shortName.getShortName() }
                        .contains(WithLenses::class.simpleName)
                 */

                // to private check fun
                if (compObj != null) {
                    logger.warn("Found new way for " + classDeclaration)

                    // to private fun
                    val allCtorVals =
                        classDeclaration.primaryConstructor!!.parameters.filter { it.isVal }.map { it.name }
                    val allProps = classDeclaration.getDeclaredProperties()
                        .filter { it.isPublic() && allCtorVals.contains(it.simpleName) }

                    logger.warn("All public CTor Params: " + allCtorVals.map { it?.getShortName() }.joinToString("; "))
                    logger.warn("All public CTor Props: " + allProps.joinToString("; "))

                    /*
                    val Person.Companion.name: String
                        get() = buildLens(...)
                     */

                    val fileSpec = FileSpec.builder(
                        packageName = packageName,
                        fileName = classDeclaration.simpleName.asString() + "Lenses"
                    ).apply {
                        addComment("GENERATED by fritz2 - NEVER CHANGE CONTENT MANUALLY!")
                        allProps.forEach { prop ->
                            val attributeName = prop.simpleName.getShortName()
                            addProperty(
                                PropertySpec.builder(
                                    prop.simpleName.getShortName(),
                                    Lens::class.asClassName().parameterizedBy(
                                        TypeVariableName(classDeclaration.qualifiedName!!.getShortName()),
                                        prop.type.toTypeName()
                                    )
                                )
                                    .receiver(compObj.asType(emptyList()).toTypeName())
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addCode("return buildLens(%S, { it.$attributeName }, { p, v -> p.copy($attributeName = v)})", attributeName)
                                            .build()
                                    )
                                    .build()
                            )
                        }
                    }.build()

                    fileSpec.writeTo(codeGenerator = codeGenerator, aggregating = false)

                } else {
                    logger.warn("Found old way for " + classDeclaration)
                }

                //logger.warn("Declarations: " + classDeclaration.declarations.joinToString("; "))
                //logger.warn("Functions: " + classDeclaration.getDeclaredFunctions().joinToString("; "))
                //logger.warn("Properties: " + classDeclaration.getDeclaredProperties().joinToString("; "))
                //logger.warn("Properties: " + classDeclaration.declarations.filterIsInstance<KSClassDeclaration>().joinToString("; "))

                //logger.warn("Companion object: " + compObj)


                //logger.warn("Declarations: " + classDeclaration.declarations.map { it }.joinToString("; "))

                /*
                val dataClass = classDeclaration.parent!! as KSClassDeclaration
                val declPs = dataClass.getDeclaredProperties()
                val allPs =
                    dataClass.primaryConstructor!!.declarations.map { it.qualifiedName } //  .parameters.map { it.name }.toSet()
                val allPublicPs = declPs.filter { it.isPublic() && !it.isMutable && allPs.contains(it.qualifiedName) }
                logger.warn("All Ctor vals of $dataClass: " + allPs.joinToString(", "))
                logger.warn("All public vals of $dataClass: " + allPublicPs.joinToString(", "))

                 */
            } else {
                logger.error("$classDeclaration is not a data class")
            }
        }

    }

    private fun KSClassDeclaration.isDataClass() =
        modifiers.contains(Modifier.DATA)
}