package dev.fritz2.lenses

import com.google.devtools.ksp.*
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.*

class LensesProcessor(
    private val options: Map<String, String>,
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val lensesAnnotated = resolver.getSymbolsWithAnnotation(Lenses::class.qualifiedName!!)
        val unableToProcess = lensesAnnotated.filterNot { it.validate() }

        /*
        logger.warn("Hello")
        logger.warn(symbols.joinToString("; "))

         */

        lensesAnnotated.filter { it is KSClassDeclaration && it.validate() }
            .forEach { it.accept(LensesVisitor(), Unit) }

        return unableToProcess.toList()
    }

    private inner class LensesVisitor : KSVisitorVoid() {
        @OptIn(KotlinPoetKspPreview::class)
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            /*
            1.) Is data class
            2.) Has companion with @WithLenses
            yes -> new way
            no -> old way
             */
            val packageName = classDeclaration.packageName.asString()

            if (classDeclaration.isDataClass()) {
                val compObj = classDeclaration.declarations
                    .filterIsInstance<KSClassDeclaration>()
                    .filter { it.isCompanionObject }
                    .firstOrNull()

                /*

 && compObj.annotations.map { it.shortName.getShortName() }
                        .contains(WithLenses::class.simpleName)
                 */

                // to private check fun
                if (compObj != null) {
                    logger.warn("Found new way for " + classDeclaration)

                    // to private fun
                    val allCtorVals =
                        classDeclaration.primaryConstructor!!.parameters.filter { it.isVal }.map { it.name }
                    val allProps = classDeclaration.getDeclaredProperties()
                        .filter { it.isPublic() && allCtorVals.contains(it.simpleName) }.toList()

                    //logger.warn("All public CTor Params: " + allCtorVals.map { it?.getShortName() }.joinToString("; "))
                    //logger.warn("All public CTor Props: " + allProps.joinToString("; "))
                    //logger.warn("Props with types: " + allProps.filter { it.typeParameters.isNotEmpty() }.joinToString("; "))
                    //logger.warn("Type Parameters for class: " + classDeclaration.typeParameters.joinToString("; "))

                    // to private fun
                    val neededFunNamesAlreadyInUse = compObj.getDeclaredFunctions()
                        .filter { declFun -> allProps.any { it.simpleName.getShortName() == declFun.simpleName.getShortName() } }
                        .toList()

                    if (neededFunNamesAlreadyInUse.isNotEmpty()) {
                        logger.error(
                            "The companion object of $classDeclaration already defines the following function(s): "
                                    + neededFunNamesAlreadyInUse.joinToString("; ")
                                    + " -> Those names must not be defined! They are used for the automatic lenses generation. "
                                    + "Please rename those existing function(s) to bypass this problem!"
                        )
                    }

                    // better name to make this more expressive: if (lenseableProps.IsNotEmpty())
                    if (allProps.isNotEmpty()) {
                        val fileSpec = FileSpec.builder(
                            packageName = packageName,
                            fileName = classDeclaration.simpleName.asString() + "Lenses"
                        ).apply {
                            addComment("GENERATED by fritz2 - NEVER CHANGE CONTENT MANUALLY!")
                            allProps.forEach { prop ->
                                val attributeName = prop.simpleName.getShortName()
                                val isGeneric = prop.type.resolve().declaration is KSTypeParameter
                                addFunction(
                                    FunSpec.builder(
                                        prop.simpleName.getShortName()
                                    )
                                        .returns(
                                            Lens::class.asClassName().parameterizedBy(
                                                if (isGeneric) classDeclaration.toClassName()
                                                    .parameterizedBy(classDeclaration.typeParameters.map { it.toTypeVariableName() })
                                                else classDeclaration.toClassName(),
                                                prop.type.toTypeName(classDeclaration.typeParameters.toTypeParameterResolver())
                                            )
                                        )
                                        .addTypeVariables(classDeclaration.typeParameters.map { it.toTypeVariableName() })
                                        .receiver(compObj.asType(emptyList()).toTypeName())
                                        .addCode(
                                            """ |return buildLens(
                                            |  %S, 
                                            |  { it.$attributeName }, 
                                            |  { p, v -> p.copy($attributeName = v)}
                                            |)
                                        """.trimMargin(),
                                            attributeName
                                        ).build()
                                )
                                //.build()
                            }
                        }.build()

                        fileSpec.writeTo(codeGenerator = codeGenerator, aggregating = false)
                    } else {
                        logger.warn(
                            "@Lenses annotated data class $classDeclaration found, but it has no public"
                                    + " properties defined in constructor -> can not create any lenses though..."
                        )
                    }
                } else {
                    logger.warn("Found old way for " + classDeclaration)
                }

                //logger.warn("Declarations: " + classDeclaration.declarations.joinToString("; "))
                //logger.warn("Functions: " + classDeclaration.getDeclaredFunctions().joinToString("; "))
                //logger.warn("Properties: " + classDeclaration.getDeclaredProperties().joinToString("; "))
                //logger.warn("Properties: " + classDeclaration.declarations.filterIsInstance<KSClassDeclaration>().joinToString("; "))

                //logger.warn("Companion object: " + compObj)


                //logger.warn("Declarations: " + classDeclaration.declarations.map { it }.joinToString("; "))

                /*
                val dataClass = classDeclaration.parent!! as KSClassDeclaration
                val declPs = dataClass.getDeclaredProperties()
                val allPs =
                    dataClass.primaryConstructor!!.declarations.map { it.qualifiedName } //  .parameters.map { it.name }.toSet()
                val allPublicPs = declPs.filter { it.isPublic() && !it.isMutable && allPs.contains(it.qualifiedName) }
                logger.warn("All Ctor vals of $dataClass: " + allPs.joinToString(", "))
                logger.warn("All public vals of $dataClass: " + allPublicPs.joinToString(", "))

                 */
            } else {
                logger.error("$classDeclaration is not a data class")
            }
        }

    }

    private fun KSClassDeclaration.isDataClass() =
        modifiers.contains(Modifier.DATA)
}