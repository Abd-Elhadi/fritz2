package dev.fritz2.lenses

import com.google.devtools.ksp.*
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.*

/**
 * TODO: Why properties and not funs -> no generic support!
 * Leading project (Arrow Optics) "suffers" from similar problem
 * https://github.com/arrow-kt/arrow/issues/2552
 */
class LensesProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val lensesAnnotated = resolver.getSymbolsWithAnnotation(Lenses::class.qualifiedName!!)
        val unableToProcess = lensesAnnotated.filterNot { it.validate() }

        lensesAnnotated.filter { it is KSClassDeclaration && it.validate() }
            .forEach { it.accept(LensesVisitor(), Unit) }

        return unableToProcess.toList()
    }

    private inner class LensesVisitor : KSVisitorVoid() {

        @OptIn(KotlinPoetKspPreview::class)
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            val packageName = classDeclaration.packageName.asString()

            if (classDeclaration.isDataClass()) {
                val compObj = classDeclaration.declarations
                    .filterIsInstance<KSClassDeclaration>()
                    .filter { it.isCompanionObject }
                    .firstOrNull()

                if (compObj != null) {
                    val lensableProps = determineLensableProperties(classDeclaration)
                    if (!assertLensesPropertyNamesAreAvailable(compObj, lensableProps, classDeclaration)) return
                    if (!assertLensesPropertiesAreNotGeneric(lensableProps, classDeclaration)) return

                    if (lensableProps.isNotEmpty()) {
                        val fileSpec = FileSpec.builder(
                            packageName = packageName,
                            fileName = classDeclaration.simpleName.asString() + "Lenses"
                        ).apply {
                            addComment("GENERATED by fritz2 - NEVER CHANGE CONTENT MANUALLY!")
                            lensableProps.forEach { prop ->
                                val attributeName = prop.simpleName.getShortName()
                                addProperty(
                                    PropertySpec.builder(
                                        prop.simpleName.getShortName(),
                                        Lens::class.asClassName()
                                            .parameterizedBy(classDeclaration.toClassName(), prop.type.toTypeName())
                                    ).receiver(compObj.asType(emptyList()).toTypeName())
                                        .initializer(
                                            """ |buildLens(
                                            |%S, 
                                            |{ it.$attributeName }, 
                                            |{ p, v -> p.copy($attributeName = v)}
                                            |)
                                        """.trimMargin(),
                                            attributeName
                                        ).build()
                                )
                            }
                        }.build()

                        fileSpec.writeTo(codeGenerator = codeGenerator, aggregating = false)
                    } else {
                        logger.warn(
                            "@Lenses annotated data class $classDeclaration found, but it has no public"
                                    + " properties defined in constructor -> can not create any lenses though..."
                        )
                    }
                } else {
                    logger.error(
                        "The companion object for data class $classDeclaration is missing!"
                                + " Please define it to bypass this error."
                    )
                }
            } else {
                logger.error("$classDeclaration is not a data class!")
            }
        }
    }

    private fun determineLensableProperties(classDeclaration: KSClassDeclaration): List<KSPropertyDeclaration> {
        val allPublicCtorProps = classDeclaration.primaryConstructor!!.parameters.filter { it.isVal }.map { it.name }
        return classDeclaration.getDeclaredProperties()
            .filter { it.isPublic() && allPublicCtorProps.contains(it.simpleName) }.toList()
    }

    private fun assertLensesPropertyNamesAreAvailable(
        compObj: KSClassDeclaration,
        lensableProps: List<KSPropertyDeclaration>,
        classDeclaration: KSClassDeclaration
    ): Boolean {
        val neededFunNamesAlreadyInUse = compObj.getDeclaredFunctions()
            .filter { declaredFunctions ->
                lensableProps.any {
                    it.simpleName.getShortName() == declaredFunctions.simpleName.getShortName()
                }
            }
            .toList()

        return if (neededFunNamesAlreadyInUse.isNotEmpty()) {
            logger.error(
                "The companion object of $classDeclaration already defines the following function(s): "
                        + neededFunNamesAlreadyInUse.joinToString("; ")
                        + " -> Those names must not be defined! They are used for the automatic lenses generation. "
                        + "Please rename those existing function(s) to bypass this problem!"
            )
            false
        } else true
    }

    private fun assertLensesPropertiesAreNotGeneric(
        lensableProps: List<KSPropertyDeclaration>,
        classDeclaration: KSClassDeclaration
    ): Boolean {
        val relevantTypeParameters = classDeclaration.typeParameters.map { it.simpleName.getShortName() }.toSet()

        fun depthFirstSearchChildTypes(typeNode: KSTypeReference): Boolean {
            return (
                    typeNode.element?.typeArguments
                        ?.map { it.type?.resolve()?.declaration?.simpleName?.getShortName() }
                        ?.any { t -> relevantTypeParameters.contains(t) } ?: false
                    )
                    ||
                    typeNode.element?.typeArguments?.any {
                        it.type?.let { childTypeNode -> depthFirstSearchChildTypes(childTypeNode) } ?: false
                    } ?: false
        }

        val dependentProps = lensableProps.filter {
            val ref = it.type.resolve().declaration
            ref is KSTypeParameter && relevantTypeParameters.contains(ref.simpleName.getShortName()) ||
                    depthFirstSearchChildTypes(it.type)
        }

        return if (dependentProps.isNotEmpty()) {
            logger.error(
                "The data class $classDeclaration has some properties depending on a type: "
                        + dependentProps.joinToString("; ")
                        + " -> But generic type parameters are not supported for lenses generation!"
            )
            false
        } else true
    }

    private fun KSClassDeclaration.isDataClass() =
        modifiers.contains(Modifier.DATA)
}