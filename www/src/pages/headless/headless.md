---
title: Headless
layout: layouts/docs.njk 
permalink: /headless/ 
eleventyNavigation:
    key: headless 
    title: Headless Components 
    order: 20
    icon: puzzle
    classes: "font-bold capitalize"
---

Anstelle des klassischen Ansatzes, fertige und dabei vollständig funktionale und durchgestylte Komponenten anzubieten,
setzt fritz2 auf einen anderen Weg: Sogenannte *Headless* Komponenten.

Diese stellen im Grunde ein Baukastensystem dar, mit dessen Hilfe sich ein Benutzer selber auf einfache Art und Weise
genau die Komponenten selber bauen kann, die er benötigt. Dabei kapseln die Headless Komponenten und deren Bausteine
einen großen Teil der zentralen Funktionen und reduzieren so den Komponentenbau primär auf das Aussehen, welches
wiederum zum Großteil durch passendes Styling erzeugt wird.

Für Hintergrundinformationen, wieso wir Headless Komponenten für den optimalen Weg halten, dem Benutzer von fritz2
Hilfe zum Komponentenbau zur Verfügung zu stellen, verweisen wir auf einen detaillierten 
[Blog-Eintrag](missing-headless-why).

## Struktur einer Komponente

Jede Komponente wird über eine Fabrik-Funktion erzeugt. In seltenen Fällen gibt es auch Varianten von Fabrik-Funktionen
(z.B. bei [switch](switch/#switchwithlabel)). Das Wort "Komponente" bezeichnet daher im folgenden auch immer 
gleichzeitig die zugehörige Fabrik-Funktion und umgekehrt.

Komponenten wiederum bestehen aus weiteren, sich oftmals tiefer verschachtelnden Bausteinen. Diese werden analog durch
Fabrik-Funktionen erzeugt.

Alle Komponenten und viele Bausteine besitzen einen eigenen *Scope*, in dem bestimmte *Felder* zur Verfügung stehen,
die für die Funktionalität einer Komponente relevant sind. Dies sind oftmals `Hook`s und `Property`s, es kann sich
aber auch um simple `var`-Felder handeln.

Fast ausnahmslos erzeugen alle Fabriken (von Komponenten und Bausteinen) immer auch einen `Tag`. Dem Komponentenbauer
stehen folglich alle Attribute des erzeugten Tags zur Verfügung, wie z.B. `className` oder auch `attr`!

```kotlin
someComponent(/* params */) {
    // Scope von `someComponent` == some `Tag` + specific extra props (`initialize`-Parameter)
    
    someBrick(/* params */) {
        // Scope von `SomeBrick` == some `Tag` + specific extra props + props from outer Scope! (`initialize`-Parameter)
    }
}
```

Bausteine haben als Präfix immer den markanten Teil oder auch den vollständigen Namen der Komponente zu der sie gehören,
z.B. `radioGroupLabel` für eine Beschriftung innerhalb der `radioGroup` Komponente.

Fast alle Fabrik-Funktionen von Komponenten und Bausteinen haben dieselbe Signatur, die bewusst der eines `Tags`
ähnlich ist:
```kotlin
fun <C : HTMLElement> RenderContext.someComponent(
    classes: String? = null, // modify the styling
    id: String? = null, // set an explicit ID; will be autogenerated in cases where this is needed
    scope: (ScopeContext.() -> Unit) = {}, // set some key-value-pairs into the scope
    tag: TagFactory<Tag<C>>, // provide a factory to create some `Tag<C>` (there is *always* an overloaded function with some default `Tag`) 
    initialize: SomeComponent<C>.() -> Unit // the builder function, that enables the component designer to define the content and access the scope of a component / brick
): Tag<C>
```

In den API-Sektionen der Komponenten werden diese Standard-Parameter nur als knappe, typ-lose Aufzählung gelistet.
Oftmals fehlt bei Bausteinen die Möglichkeit, eine ID explizit zu setzen.

Wichtiger sind hingegen *zusätzliche* Parameter, die der ein oder andere Baustein benötigt. Diese sind daher bewusst
beschrieben und damit leicht zu erkennen. Zumeist sind das entsprechend auch Pflichtparameter.

## API-Beschreibung

Da jede Komponente aus vielen verschiedenen Bausteinen besteht und diese wiederum selber einige Felder mit `Hook`s,
`Property`s oder auch einfachen `var`-Typen anbieten, wird eine stark abstrahierende Übersicht geboten. Diese 
fokussiert sich auf die speziellen Headless-Aspekte und deutet per Kommentar auch hilfreiche Muster an.
Standard-Parameter oder Felder der Default-Tags werden hingegen ausgespart.

Folgendes Beispiel soll die Darstellung zeigen. Zur Verdeutlichung sind die Strukturen hier zusätzlich kommentiert;
in den Komponenten-Dokumentationen fehlen diese Meta-Informationen.

```kotlin
// Komponenten Fabrik
someComponent() {
    // Felder
    val value: DatabindingProperty<Int>
    var visibleItems: Int
    
    // Bausteine
    someBrick() { }
    someOtherBrick() {
        // eigener Scope mit eigenen Feldern und Sub-Bausteinen
        val msgs: Flow<List<Messages>>
    }
    // Andeutung eines relevanten Musters:
    // for each item {
        someRepeatingBrick(item: T) {
        //                 ^^^^^^^
        //                 mandatory additional parameter!
            
            // eigenes Feld
            val selected: Flow<Boolean>
        }
    // }
    
}
```

## Komponente = Headless + Tags + Styling

Um aus den Headless Komponenten und deren Bausteinen eine funktionierende Komponente zu erzeugen, müssen die
gegebenen Fabrik-Funktionen derartig ineinander geschachtelt und mit weiteren `Tags` kombiniert werden, so dass die
gewünschte Gesamtstruktur entsteht. Zusätzlich muss das Aussehen über das Hinzufügen von Styling definiert werden.

Die Headless-Komponenten und -Bausteine bieten dabei folgende Ansatzpunkte, um Funktion und Aussehen der Komponente
zu definieren:
- Verwendung eines bestimmten, optionalen Bausteins
- Bestimmen des zu erzeugenden `Tag`s in den Fabrik-Funktionen
- Setzen von Styling-Angaben in den Fabrik-Funktionen
- Zugriff auf die Felder im Scope der Komponenten oder des Bausteins

### Verwendung eines bestimmten, optionalen Bausteins

Bausteine besitzen oftmals in sich eine Funktionalität, die alleine durch deren Verwendung innerhalb einer Komponente
aktiviert wird. Gute Beispiele dafür sind die diversen `*Label`, die idR. bestimmte 
[ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) Attribute setzen oder auch etablierte 
Funktionen auslösen.

Ein gutes Beispiel dafür sind die Labels bei den Text-Komponenten [InputField](#inputField) und [TextArea](#textArea).
Werden diese verwendet, so fokussiert ein Maus-Klick auf diese Elemente automatisch das zugehörige Eingabefeld.

Diese Funktion ist ohne weiteres Zutun des Komponentendesigners verfügbar, sobald der entsprechende `*Label`-Baustein
im Scope der Komponente aufgerufen wird.

Weitere Beispiele finden sich in den diversen `*Toggle`-Bausteinen (wie z.B. 
[checkboxGroupOptionToggle](checkboxgroup/#checkboxgroupoptiontoggle)), die automatisch das Selektieren / Deselektieren
von Items aufgrund von definierten Benutzer-Eingaben vornehmen. Der Designer muss nichts weiter tun, als diese
Bausteine entsprechend in seiner Komponente zu "platzieren".

### Bestimmen des zu erzeugenden `Tag`s in den Fabrik-Funktionen

Die Headless-Komponenten und deren Bausteine bieten immer einen guten Default-Typen für das zu erzeugende `Tag` an.
Um aber die größt mögliche Flexibilität zu erreichen, kann der Komponentenbauer den Typen des Tags frei wählen.

So kann er das für sich semantisch passende Tag erzeugen.

Auch hier können wieder die `*Label`-Attribute als Beispiel dienen. Diese erzeugen zumeist tatsächlich HTML 
`label`-Tags. Eine einfache Angabe des `tag`-Parameter genügt:
```kotlin
inputField() {
    inputFieldLabel(tag = RenderContext:: Span) { // Scope von `HTMLSpanElement`
        +"Some Label Text"
    }
}
```

### Setzen von Styling-Angaben in den Fabrik-Funktionen

Fast jede Fabrik-Funktion akzeptiert einen `classes`-Parameter, mit welchem beliebige CSS-Klassen an den zu erzeugenden
`Tag` gesetzt werden können. Damit kann der Komponentendesigner einfach das Aussehen bestimmen. Dies ist umso wichtiger,
als dass das Styling fast immer im Gesamtkontext der Komponente zu sehen ist.

```kotlin
inputField() {
    inputFieldLabel("text-indigo-500 p-8 mh-4") {
    //               ^^^^^^^^^^^^^^^^^^^^^^^^
    //               Some Styling, almost always first parameter, we use Tailwind CSS here
        +"Some Label Text"
    }
}
```

### Zugriff auf die Felder im Scope der Komponenten oder des Bausteins

Als letzter und dafür auch extrem mächtiger Aspekt stellen die Komponenten und Bausteine wichtige Zusatzfelder zum
Scope des erzeugten Tags bereit. Diese Felder sind oftmals `Property`s und `Hook`s. (vg. Beschreibung weiter unten).

In diesen Feldern wird dem Komponentenbauer oftmals Zugriff auf einen aktuellen Status gegeben, oder dieser kann
bestimmen, wie der Status ggf. geändert werden soll. Die (Zwei-Wege-)Datenbindung findet z.B. *immer* über eine
entsprechende `Property` statt, die vom Designer gefüllt werden muss. Dies umfasst z.B. die Informationen
über die Selektion bei den Auswahlkomponenten ([RadioGroup](radioGroup), [CheckboxGroup](checkboxGroup) oder
[ListBox](listBox)), aber auch die Eingabewerte bei Textfeld-Komponenten ([InputField](inputField) 
und [TextArea](textArea)).

Dazu kommen auch oftmals bestimmte `Flow`s und `Handler`, über welche man spezielle Zustände (selektiert, disabled,
fokussiert oder geöffnet) abfragen oder entsprechend auch das Verhalten bei Änderungen (Anwender klickt auf einen
*close*-Button) definieren kann.

Typische Muster sind das dynamische Setzen von Stylings in Abhängigkeit eines bestimmten Zustands über `className` 
oder auch das komplette Erzeugen oder Löschen von Strukturen:

```kotlin
checkboxGroup {
    // Special Databinding-Property for the selection management.
    // Component will automatically use the current selections and also set or remove those by user interaction. 
    value(someStore)
    
    checkboxGroupOption(option) {
        // offers `selected: Flow<Boolean>` property -> style checked and unchecked options differently
        className(selected.map {
            if (it) "ring-2 ring-indigo-500 border-transparent"
            else "border-gray-300"
        })
        
        // Conditionally modify a whole sub-structure: Show an Icon only if option is selected
        selected.render {
            if (it) {
                svg("h-5 w-5 text-indigo-600") {
                    content(HeroIcons.check_circle)
                    fill("currentColor")
                }
            }
        }
    }
}
```

## Properties
 beschreiben


## Hooks
 beschreiben


## Databinding

Einige Headless-Komponenten unterstützen Databinding. Das bedeutet, dass...
Hier beschreiben, wie die Property-aufgebaut ist, die unterschiedlichen Verwendungsarten, etc, so dass an der Komponenten nur noch der Datentyp, etc. genannt werden muss und ob DB unterstützt wird oder nicht.

## Closable Content - OpenClose

Einige der Headless Komponenten können geöffnet und geschlossen werden, beispielsweise indem im geöffneten Zustand content ausklappt (`disclosure`) oder ein PopUp erscheint (`popOver`). Diese Komponenten implementieren die abstrakte Klasse `OpenClose`.

Im Scope von dieser Komponenten stehen verschiedene `Flow`s und `Handler` bereit, um auf den Öffnungszustand der Komponente zu reagieren oder diesen zu beeinflussen:

- `opened: Flow<Boolean>` beschreibt, ob die Komponente geöffnet oder geschlossen ist
- `open : Handler<Unit>` öffnet die Komponente
- `close : Handler<Unit>` schließt die Komponente
- `toggle : Handler<Unit>` schließt die Komponente, wenn sie geöffnet ist und andersherum

Der Öffnungszustand einer solchen Komponente kann über die Property `openClose` per Databinding z.B. an einen externen `Store` oder `Flow` gebunden werden. Über diesen kann z.B. die Sichtbarkeit der Auswahlliste einer `listbox` dann unabhängig vom Standardverhalten gesteuert werden, also z.B. immer offen gehalten werden:

```kotlin
listbox<String> {
    //...

    listboxItems {
        openClose(data = flowOf(true))
        
        characters.forEach { entry ->
            listboxItem(entry) {
                //...
            }
        }
    }
}
```

## Floating Content - PopUpPanel

Einige Bausteine der Headless Komponenten (z.B. das `popOverPanel` oder die `listboxItem`) werden dynamisch positioniert und schweben über dem übrigen Inhalt. Oft werden diese auch dynamisch ein- und ausgeblendet.

Diese Bausteine sind mit Hilfe der Bibliothek [Popper.js]("https://popper.js.org/") realisiert. Dementsprechend bieten sie eine einheitliche Konfigurationsschnittstelle, um die wichtigsten Attribute  

Im Scope eines solchen Bausteins, der die abstrakte Klasse `PopUpPanel` implementiert, stehen folgende Konfigurationen zur Verfügung, um die Positionierung des Inhaltes zu beeinflussen:

- `placement` definiert die Position des Bausteins, z.B. `Placement.top`, `Placement.bottomRight`, etc. Standardwert ist `Placement.auto`. Hierbei wird die vermutlich beste Position automatisch anhand des zur Verfügung stehenden sichtbaren Platzes bestimmt.
- `strategy` legt fest, ob der Baustein `absolute` positioniert werden soll (default) oder `fixed`.
- `flip` kommt der Baustein zu nah an den Rand des sichtbaren Bereichs, wechselt die Position automatisch auf die jeweils andere Seite, wenn dort mehr Platz zur Verfügung steht.
- `distance` definiert den Abstand der Auswahlliste vom Referenzelement in Pixeln. Der Standardwert ist 10.
- `skidding` definiert die Verschiebung der Auswahlliste entlang des Referenzelements in Pixeln. Der Standardwert ist 0.

