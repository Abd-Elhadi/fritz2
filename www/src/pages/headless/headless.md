---
title: Headless
layout: layouts/docsWithContentNav.njk
permalink: /headless/ 
eleventyNavigation:
    key: headless 
    title: Headless Components 
    order: 20
    icon: puzzle
    classes: "font-bold capitalize"
---

Anstelle des klassischen Ansatzes, fertige und dabei vollständig funktionale und durchgestylte Komponenten anzubieten,
setzt fritz2 auf einen anderen Weg: Sogenannte *Headless* Komponenten.

Diese stellen im Grunde ein Baukastensystem dar, mit dessen Hilfe sich ein Benutzer selber auf einfache Art und Weise
genau die Komponenten selber bauen kann, die er benötigt. Dabei kapseln die Headless Komponenten und deren Bausteine
einen großen Teil der zentralen Funktionen und reduzieren so den Komponentenbau primär auf das Aussehen, welches
wiederum zum Großteil durch passendes Styling erzeugt wird.

Für Hintergrundinformationen, wieso wir Headless Komponenten für den optimalen Weg halten, dem Benutzer von fritz2
Hilfe zum Komponentenbau zur Verfügung zu stellen, verweisen wir auf einen detaillierten 
[Blog-Eintrag](missing-headless-why).

## Struktur einer Komponente

Jede Komponente wird über eine Fabrik-Funktion erzeugt. In seltenen Fällen gibt es auch Varianten von Fabrik-Funktionen
(z.B. bei [switch](switch/#switchwithlabel)). Das Wort "Komponente" bezeichnet daher im folgenden auch immer 
gleichzeitig die zugehörige Fabrik-Funktion und umgekehrt.

Komponenten wiederum bestehen aus weiteren, sich oftmals tiefer verschachtelnden Bausteinen. Diese werden analog durch
Fabrik-Funktionen erzeugt.

Alle Komponenten und viele Bausteine besitzen einen eigenen *Scope*, in dem bestimmte *Felder* zur Verfügung stehen,
die für die Funktionalität einer Komponente relevant sind. Dies sind oftmals `Hook`s und `Property`s, es kann sich
aber auch um simple `var`-Felder handeln.

Fast ausnahmslos erzeugen alle Fabriken (von Komponenten und Bausteinen) immer auch einen `Tag`. Dem Komponentenbauer
stehen folglich alle Attribute des erzeugten Tags zur Verfügung, wie z.B. `className` oder auch `attr`!

```kotlin
someComponent(/* params */) {
    // Scope von `someComponent` == some `Tag` + specific extra props (`initialize`-Parameter)
    
    someBrick(/* params */) {
        // Scope von `SomeBrick` == some `Tag` + specific extra props + props from outer Scope! (`initialize`-Parameter)
    }
}
```

Bausteine haben als Präfix immer den markanten Teil oder auch den vollständigen Namen der Komponente zu der sie gehören,
z.B. `radioGroupLabel` für eine Beschriftung innerhalb der `radioGroup` Komponente.

Fast alle Fabrik-Funktionen von Komponenten und Bausteinen haben dieselbe Signatur, die bewusst der eines `Tags`
ähnlich ist:
```kotlin
fun <C : HTMLElement> RenderContext.someComponent(
    classes: String? = null, // modify the styling
    id: String? = null, // set an explicit ID; will be autogenerated in cases where this is needed
    scope: (ScopeContext.() -> Unit) = {}, // set some key-value-pairs into the scope
    tag: TagFactory<Tag<C>>, // provide a factory to create some `Tag<C>` (there is *always* an overloaded function with some default `Tag`) 
    initialize: SomeComponent<C>.() -> Unit // the builder function, that enables the component designer to define the content and access the scope of a component / brick
): Tag<C>
```

In den API-Sektionen der Komponenten werden diese Standard-Parameter nur als knappe, typ-lose Aufzählung gelistet.
Oftmals fehlt bei Bausteinen die Möglichkeit, eine ID explizit zu setzen.

Wichtiger sind hingegen *zusätzliche* Parameter, die der ein oder andere Baustein benötigt. Diese sind daher bewusst
beschrieben und damit leicht zu erkennen. Zumeist sind das entsprechend auch Pflichtparameter.

## API-Beschreibung

Da jede Komponente aus vielen verschiedenen Bausteinen besteht und diese wiederum selber einige Felder mit `Hook`s,
`Property`s oder auch einfachen `var`-Typen anbieten, wird eine stark abstrahierende Übersicht geboten. Diese 
fokussiert sich auf die speziellen Headless-Aspekte und deutet per Kommentar auch hilfreiche Muster an.
Standard-Parameter oder Felder der Default-Tags werden hingegen ausgespart.

Folgendes Beispiel soll die Darstellung zeigen. Zur Verdeutlichung sind die Strukturen hier zusätzlich kommentiert;
in den Komponenten-Dokumentationen fehlen diese Meta-Informationen.

```kotlin
// Komponenten Fabrik
someComponent() {
    // Felder
    val value: DatabindingProperty<Int>
    var visibleItems: Int
    
    // Bausteine
    someBrick() { }
    someOtherBrick() {
        // eigener Scope mit eigenen Feldern und Sub-Bausteinen
        val msgs: Flow<List<Messages>>
    }
    // Andeutung eines relevanten Musters:
    // for each item {
        someRepeatingBrick(item: T) {
        //                 ^^^^^^^
        //                 mandatory additional parameter!
            
            // eigenes Feld
            val selected: Flow<Boolean>
        }
    // }
    
}
```

## Komponente = Headless + Tags + Styling

Um aus den Headless Komponenten und deren Bausteinen eine funktionierende Komponente zu erzeugen, müssen die
gegebenen Fabrik-Funktionen derartig ineinander geschachtelt und mit weiteren `Tags` kombiniert werden, so dass die
gewünschte Gesamtstruktur entsteht. Zusätzlich muss das Aussehen über das Hinzufügen von Styling definiert werden.

Die Headless-Komponenten und -Bausteine bieten dabei folgende Ansatzpunkte, um Funktion und Aussehen der Komponente
zu definieren:
- Verwendung eines bestimmten, optionalen Bausteins
- Bestimmen des zu erzeugenden `Tag`s in den Fabrik-Funktionen
- Setzen von Styling-Angaben in den Fabrik-Funktionen
- Zugriff auf die Felder im Scope der Komponenten oder des Bausteins

### Verwendung eines bestimmten, optionalen Bausteins

Bausteine besitzen oftmals in sich eine Funktionalität, die alleine durch deren Verwendung innerhalb einer Komponente
aktiviert wird. Gute Beispiele dafür sind die diversen `*Label`, die idR. bestimmte 
[ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) Attribute setzen oder auch etablierte 
Funktionen auslösen.

Ein gutes Beispiel dafür sind die Labels bei den Text-Komponenten [InputField](#inputField) und [TextArea](#textArea).
Werden diese verwendet, so fokussiert ein Maus-Klick auf diese Elemente automatisch das zugehörige Eingabefeld.

Diese Funktion ist ohne weiteres Zutun des Komponentendesigners verfügbar, sobald der entsprechende `*Label`-Baustein
im Scope der Komponente aufgerufen wird.

Weitere Beispiele finden sich in den diversen `*Toggle`-Bausteinen (wie z.B. 
[checkboxGroupOptionToggle](checkboxgroup/#checkboxgroupoptiontoggle)), die automatisch das Selektieren / Deselektieren
von Items aufgrund von definierten Benutzer-Eingaben vornehmen. Der Designer muss nichts weiter tun, als diese
Bausteine entsprechend in seiner Komponente zu "platzieren".

### Bestimmen des zu erzeugenden `Tag`s in den Fabrik-Funktionen

Die Headless-Komponenten und deren Bausteine bieten immer einen guten Default-Typen für das zu erzeugende `Tag` an.
Um aber die größt mögliche Flexibilität zu erreichen, kann der Komponentenbauer den Typen des Tags frei wählen.

So kann er das für sich semantisch passende Tag erzeugen.

Auch hier können wieder die `*Label`-Attribute als Beispiel dienen. Diese erzeugen zumeist tatsächlich HTML 
`label`-Tags. Eine einfache Angabe des `tag`-Parameter genügt:
```kotlin
inputField() {
    inputFieldLabel(tag = RenderContext:: Span) { // Scope von `HTMLSpanElement`
        +"Some Label Text"
    }
}
```

### Setzen von Styling-Angaben in den Fabrik-Funktionen

Fast jede Fabrik-Funktion akzeptiert einen `classes`-Parameter, mit welchem beliebige CSS-Klassen an den zu erzeugenden
`Tag` gesetzt werden können. Damit kann der Komponentendesigner einfach das Aussehen bestimmen. Dies ist umso wichtiger,
als dass das Styling fast immer im Gesamtkontext der Komponente zu sehen ist.

```kotlin
inputField() {
    inputFieldLabel("text-indigo-500 p-8 mh-4") {
    //               ^^^^^^^^^^^^^^^^^^^^^^^^
    //               Some Styling, almost always first parameter, we use Tailwind CSS here
        +"Some Label Text"
    }
}
```

### Zugriff auf die Felder im Scope der Komponenten oder des Bausteins

Als letzter und dafür auch extrem mächtiger Aspekt stellen die Komponenten und Bausteine wichtige Zusatzfelder zum
Scope des erzeugten Tags bereit. Diese Felder sind oftmals [`Property`s](#properties) und [`Hook`s](#hooks).

In diesen Feldern wird dem Komponentenbauer oftmals Zugriff auf einen aktuellen Status gegeben, oder dieser kann
bestimmen, wie der Status ggf. geändert werden soll. Die (Zwei-Wege-)Datenbindung findet z.B. *immer* über eine
entsprechende `Property` statt, die vom Designer gefüllt werden muss. Dies umfasst z.B. die Informationen
über die Selektion bei den Auswahlkomponenten ([RadioGroup](radioGroup), [CheckboxGroup](checkboxGroup) oder
[ListBox](listBox)), aber auch die Eingabewerte bei Textfeld-Komponenten ([InputField](inputField) 
und [TextArea](textArea)).

Dazu kommen auch oftmals bestimmte `Flow`s und `Handler`, über welche man spezielle Zustände (selektiert, disabled,
fokussiert oder geöffnet) abfragen oder entsprechend auch das Verhalten bei Änderungen (Anwender klickt auf einen
*close*-Button) definieren kann.

Typische Muster sind das dynamische Setzen von Stylings in Abhängigkeit eines bestimmten Zustands über `className` 
oder auch das komplette Erzeugen oder Löschen von Strukturen:

```kotlin
checkboxGroup {
    // Special Databinding-Property for the selection management.
    // Component will automatically use the current selections and also set or remove those by user interaction. 
    value(someStore)
    
    checkboxGroupOption(option) {
        // offers `selected: Flow<Boolean>` property -> style checked and unchecked options differently
        className(selected.map {
            if (it) "ring-2 ring-indigo-500 border-transparent"
            else "border-gray-300"
        })
        
        // Conditionally modify a whole sub-structure: Show an Icon only if option is selected
        selected.render {
            if (it) {
                svg("h-5 w-5 text-indigo-600") {
                    content(HeroIcons.check_circle)
                    fill("currentColor")
                }
            }
        }
    }
}
```

## Basiskonzepte für Daten- und Verhaltensmanagement

Headless Komponenten und Bausteine benötigen unabhängig von der konkreten Ausprägung oftmals ähnliche Mechanismen,
wie sie bestimmte Daten von einem Benutzer einfordern und verwalten. Über das reine Datenmanagement hinaus, muss es
dem Benutzer auch möglich sein, direkt in das Rendering einzugreifen und individuelles Verhalten in die Komponente
oder den Baustein hineinzureichen.

Dafür existieren zwei Grundkonzepte, die im folgenden genauer vorgestellt werden sollen:
- Properties
- Hooks

Da die Datenanbindung besonders wichtig ist, wird diese spezielle Implementierung einer `Property` separat in einem
Abschnitt erläutert.

### Properties

Eine `Property` dient als Container für idR. zusammengesetzte Daten, die von einer Komponente oder einem Baustein 
für die Erfüllung seiner Aufgabe relevant sind und vom Anwender von außen konfiguriert werden müssen. 
Die Property wird entsprechend immer von der jeweiligen Headless-Instanz angelegt und in ihrem Scope dem Benutzer 
exponiert. 

Um dieses öffentliche API so passend wie möglich zu schneiden, sieht das Konzept vor, die benötigten Daten mittels
`invoke`-Methode anzubieten, die dann intern den Datensatz ablegen. Daraus ergibt sich automatisch, dass das 
öffentliche API zum Setzen von Daten immer eindeutig und einheitlich definiert ist. Zusätzlich wird es einfach möglich,
Überladungen für gängige Fälle anzubieten, wenn solche Daten heterogen vorliegen können: 

```kotlin
class UserProperty : Property<User>() {
     // Only visible "modifying" API for the client, "hide" the complex type by offering the parameters directly!
    operator fun invoke(name: String, alias: String, mail: String) {
         value = User(name, alias, mail)
    }
    
    // perhaps some other `invoke`s with convenience parameters!
    operator fun invoke(ldapData: LdapPrincipal) {
        value = User(/* extract the relevant parameters from `LdapPrincipal` instance */)
    }
}

// set the data within some headless-component:
someComponentOrBrick {
    user("Christian", "Chris", "chris@fritz2.org")
}
```

Die Komponente selber kann gängige Probleme dann dank der `Property`-Schnittstelle lösen:
- Prüfen mittels `isSet` ob ein Wert gesetzt wurde. Dies ist wichtig, um ggf. auf einen default-Wert zurückgreifen
 zu können.
- Weiterreichen des Datensatzes an eine andere Property-Instanz per ``use(item: T)``. Dies ist entscheidend für den
 Komponentenbauer, da solche Daten sehr oft auch unmittelbar durch die fertige Komponente öffentlich zur Konfiguration 
 exponiert und dann an die Headless-Komponente oder den -Baustein weiter durchgereicht werden müssen.

```kotlin
class SomeSpecificComponent {
    
    // create Property instance, so external user can provide user data
    val user = UserProperty()
    
    fun render() {
        someHeadlessComponent() {
            
            // transfer data into the headless component, which requires it!
            user.use(this@SomeSpecificComponent.user.value)
            
            someBrick() {
                // `someBrick` might check if `user.isSet` and use some default fallback data by itself!
                // often the component can check and act in the same way too:
                if(user.isSet) {
                    // apply user data
                } else {
                    // act without user data provided
                }
            }
        }
    }
}
```

**Hinweis:** Wenn es sich um einen atomaren Wert handelt, etwa ein String für ein Styling oder ein spezieller `enum class`-Wert,
so sollte man durchaus auf eine extra Property-Implementierung verzichten, und das ganze über ein `public var` lösen!
(vgl. [Ausirchtung von TabGroups](tabgroup/#vertikale-tabgroup))

### Databinding

Einige Headless-Komponenten unterstützen Databinding. Das bedeutet, dass die Komponente auf dynamische Daten von außen
reagiert, diese Daten ggf. intern weiterverarbeitet und nutzt, sowie in der Lage ist, Änderungen auch wieder nach
außen weiterzureichen. Dies entspricht der klassischen Zwei-Wege-Datenbindung, die den Kern von fritz2 ausmacht.

Aufgrund der Wichtigkeit dieses Mechanismus existiert eine spezialisierte `Property` namens `DatabindingProperty<T>`.

Diese Property fordert daher folgende Parameter per `invoke` für die Verwendung:
- `id: String? = null`: Eine optionale ID, welche idR. die Basis für die weiteren Sub-Strukturen einer 
 Headless-Komponente bildet.
- `data: Flow<T>`: Muss zwingend angegeben werden. Dieser Datenstrom liefert die dynamischen Daten von außen, auf die
 die Komponente reagieren muss.
- `messages: Flow<List<ComponentValidationMessage>>? = null`: Dieser Datenstrom ermöglicht die optionale Weitergabe
 von Validierungsnachrichten. Viele Headless-Komponenten unterstützen diesen Aspekt bereits nativ!
- `handler: ((Flow<T>) -> Unit)? = null`: Ein optionaler Handler, der definiert, wie die Komponente intern gemachte
 Änderungen wieder nach draußen reichen soll.

Da sich diese Informationen allesamt aus einem `Store` ableiten lassen, bietet die Property eine entsprechend
überladene `invoke`-Methode an, die genau das anbietet.

Damit ermöglicht es diese spezielle Property dem Komponentenbauer, sehr einfach und mit stark reduziertem 
Boilerplate-Code, die Daten für die Datenbindung zu exponieren und zu verwalten.

```kotlin
val name = storeOf("fritz2")

inputField {
    
    // pass the store into the data-binding-property `value`, so that the input-field can be preset with external data
    // and also react to user input to update the external store.
    value(name)
    
    // ...
}
```

### Hooks
 beschreiben


## Mehrfach genutzte Basisklassen 

### Closable Content - OpenClose

Einige der Headless Komponenten können geöffnet und geschlossen werden, beispielsweise indem im geöffneten Zustand content ausklappt (`disclosure`) oder ein PopUp erscheint (`popOver`). Diese Komponenten implementieren die abstrakte Klasse `OpenClose`.

Im Scope von dieser Komponenten stehen verschiedene `Flow`s und `Handler` bereit, um auf den Öffnungszustand der Komponente zu reagieren oder diesen zu beeinflussen:

- `opened: Flow<Boolean>` beschreibt, ob die Komponente geöffnet oder geschlossen ist
- `open : Handler<Unit>` öffnet die Komponente
- `close : Handler<Unit>` schließt die Komponente
- `toggle : Handler<Unit>` schließt die Komponente, wenn sie geöffnet ist und andersherum

Der Öffnungszustand einer solchen Komponente kann über die Property `openClose` per Databinding z.B. an einen externen `Store` oder `Flow` gebunden werden. Über diesen kann z.B. die Sichtbarkeit der Auswahlliste einer `listbox` dann unabhängig vom Standardverhalten gesteuert werden, also z.B. immer offen gehalten werden:

```kotlin
listbox<String> {
    //...

    listboxItems {
        openClose(data = flowOf(true))
        
        characters.forEach { entry ->
            listboxItem(entry) {
                //...
            }
        }
    }
}
```

### Floating Content - PopUpPanel

Einige Bausteine der Headless Komponenten (z.B. das `popOverPanel` oder die `listboxItem`) werden dynamisch positioniert und schweben über dem übrigen Inhalt. Oft werden diese auch dynamisch ein- und ausgeblendet.

Diese Bausteine sind mit Hilfe der Bibliothek [Popper.js]("https://popper.js.org/") realisiert. Dementsprechend bieten sie eine einheitliche Konfigurationsschnittstelle, um die wichtigsten Attribute  

Im Scope eines solchen Bausteins, der die abstrakte Klasse `PopUpPanel` implementiert, stehen folgende Konfigurationen zur Verfügung, um die Positionierung des Inhaltes zu beeinflussen:

- `placement` definiert die Position des Bausteins, z.B. `Placement.top`, `Placement.bottomRight`, etc. Standardwert ist `Placement.auto`. Hierbei wird die vermutlich beste Position automatisch anhand des zur Verfügung stehenden sichtbaren Platzes bestimmt.
- `strategy` legt fest, ob der Baustein `absolute` positioniert werden soll (default) oder `fixed`.
- `flip` kommt der Baustein zu nah an den Rand des sichtbaren Bereichs, wechselt die Position automatisch auf die jeweils andere Seite, wenn dort mehr Platz zur Verfügung steht.
- `distance` definiert den Abstand der Auswahlliste vom Referenzelement in Pixeln. Der Standardwert ist 10.
- `skidding` definiert die Verschiebung der Auswahlliste entlang des Referenzelements in Pixeln. Der Standardwert ist 0.

