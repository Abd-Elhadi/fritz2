
<!-- Start Example -->
<div class="mt-12 sm:mt-24 mx-4 sm:mx-auto max-w-4xl overflow-hidden bg-gray-50 border border-gray-200 rounded-md divide-y divide-gray-200">
    <div class="py-6 px-6 bg-gradient-to-r from-teal-500 to-cyan-600 text-white text-2xl font-nunito font-bold">
        Getting Started
    </div>
    <div class="p-4">
        <p class="pb-4 prose max-w-prose">
            Lets start to create our first elements, or as we called them <em>tags</em>, by using the DSL.
            We need to call the <code>render</code> function at first in order to create a <code>RenderContext</code>
            where we can put our tags in. Every tag is just a function representing an HTML-element like <code>div</code> here.
            You can nest them like in HTML. For styling purposes you can add your CSS-class-names directly as first parameter.
        </p>
        <div class="grid grid-cols-1 gap-2 sm:grid-cols-2">
            {% highlight "kotlin" %}
fun main() {
    render {
        div("my-style-class") {
            h2 {
                +"Hello Peter!"
            }
        }
    }
}
            {% endhighlight %}
            <div class="border border-gray-200 bg-gray-300 h-full overflow-hidden rounded-md">
                <div class="p-3 uppercase text-gray-700">
                    Result
                </div>
                <div class="h-full">
                    <iframe class="w-full h-full" src="/examples-demo/index.html#start"></iframe>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Simple Example -->
<div class="mt-12 sm:mt-24 mx-4 sm:mx-auto max-w-4xl overflow-hidden bg-gray-50 border border-gray-200 rounded-md divide-y divide-gray-200">
    <div class="py-6 px-6 bg-gradient-to-r from-teal-500 to-cyan-600 text-white text-2xl font-nunito font-bold">
        Structuring your UI
    </div>
    <div class="p-4">
        <p class="pb-4 prose max-w-prose">
            To structure your UI in reusable fragments just use functions with <code>RenderContext</code> receiver.
            Inside every render-context you can call your function.
            Here we created a <code>greet</code> function and call it multiple times with different <code>name</code>s.
        </p>
        <div class="grid grid-cols-1 gap-2 sm:grid-cols-2">
                {% highlight "kotlin" %}
fun RenderContext.greet(name: String) {
    h2 {
        +"Hello $name!"
    }
}

render {
    div("my-style-class") {
        greet("Peter")
        greet("Paul")
        greet("Marry")
    }
}
                {% endhighlight %}
            <div class="border border-gray-200 bg-gray-300 h-full overflow-hidden rounded-md">
                <div class="p-3 uppercase text-gray-700">
                    Result
                </div>
                <div class="h-full">
                    <iframe class="w-full h-full" src="/examples-demo/index.html#simple"></iframe>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Reactive Example -->
<div class="mt-12 sm:mt-24 mx-4 sm:mx-auto max-w-4xl overflow-hidden bg-gray-50 border border-gray-200 rounded-md divide-y divide-gray-200">
    <div class="py-6 px-6 bg-gradient-to-r from-teal-500 to-cyan-600 text-white text-2xl font-nunito font-bold">
        Getting Reactive
    </div>
    <div class="p-4">
        <p class="pb-4 prose max-w-prose">
            Lets getting more reactive by using a <code>Store</code> to save our data in.
            Stores will be needed to get the two-way data-binding done in fritz2.
            We get the data out as <code>Flow</code> by calling <code>store.data</code>
            and render it into the <code>value</code> attribute of the <code>&lt;input&gt;</code> tag (one-way).
            To update the data inside the store we have to call the <code>update</code> handler by using the
            <code>handledBy</code> function (two-way).
        </p>
        <div class="grid grid-cols-1 gap-2 sm:grid-cols-2">
                {% highlight "kotlin" %}
val store = storeOf("Hello Peter")

render {
    div("...") {
        input("...") {
            type("text")
            value(store.data)
            changes.values() handledBy store.update
        }
        p("...") {
            store.data.renderText(into = this)
        }
    }
}
                {% endhighlight %}
            <div class="border border-gray-200 bg-gray-300 h-full overflow-hidden rounded-md">
                <div class="p-3 uppercase text-gray-700">
                    Result
                </div>
                <div class="h-full">
                    <iframe class="w-full h-full" src="/examples-demo/index.html#reactive"></iframe>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Complex Example -->
<div class="mt-12 sm:mt-24 mx-4 sm:mx-auto max-w-4xl overflow-hidden bg-gray-50 border border-gray-200 rounded-md divide-y divide-gray-200">
    <div class="py-6 px-6 bg-gradient-to-r from-teal-500 to-cyan-600 text-white text-2xl font-nunito font-bold">
        Validation
    </div>
    <div class="p-4">
        <p class="pb-4 prose max-w-prose">
<!--
            Unser Focus bei fritz2 liegt auf dem data-handling. D.h. die UI ist eigentlich nur eine Ableitung auf Basis von Regeln der
            zugrunde liegenden Daten. In echten Anwendungen ist daher die Richtigkeit der Daten wichtig. Daher bietet
            fritz2 Möglichkeiten diese mit Hilfe einer Validierung zu gewährleisten und dem Anwender entsprechende Hinweise zu geben.
            Dazu erstellen wir eine <code>Message</code> class für unsere Meldungen und eine <code>validation</code> function
            mit den Regeln zur Prüfung der Validität. Dann benutzen wir wieder unseren store zur Datenverwaltung und geben ihm
            die Validierung mit. Zum Schluss sorgen wir noch für das Anwender-Feedback indem wir den <code>store.messages</code> flow
            rausrendern.
-->
            As you have seen already, fritz2 considers data-handling as first class citizen of any reactive web-app. 
            You can think of the UI as a rule driven, derived representation from the application data.
            That's why our framework natively also supports the validation aspect as part of the data-handling.
        </p>
        <p class="pb-4 prose max-w-prose">
            In order to evaluate the data correctness, you should create a container for the messages implementing 
            <code>ValidationMessage</code> and you have to provide a <code>Validation</code> instance by the factory 
            function <code>validation</code>. The latter contains all the domain rules to check the validity state. 
            There is a special <code>store</code> factory function that directly accepts a 
            <code>Validation</code>-object, which will be evaluated on each update automatically. Last but not least 
            we use the provided <code>store.messages</code> flow, to give the user feedback about possible failures 
            or warnings.
        </p>
        <div class="grid grid-cols-1 gap-2 sm:grid-cols-2">
            <div>
                {% highlight "kotlin" %}
class Message(
    override val path: String,
    val text: String
): ValidationMessage {
    override val isError: Boolean = true
}

val mailRegex = Regex("""\S+@\S+\.\S+""")
val validation = validation<String, Message> {
    if(!mailRegex.matches(it.data))
        add(Message(it.path,"Not a valid mail address"))
}

val store = storeOf("", validation)

render {
    div("...") {
        input("...") {
            type("text")
            placeholder("Enter e-mail address")
            value(store.data)
            changes.values() handledBy store.update
        }
        store.messages.renderEach {
            p("...") {
                +it.text
            }
        }
    }
}
                {% endhighlight %}
            </div>
            <div class="border border-gray-200 bg-gray-300 h-full overflow-hidden rounded-md">
                <div class="p-3 uppercase text-gray-700">
                    Result
                </div>
                <div class="h-full">
                    <iframe class="w-full h-full" src="/examples-demo/index.html#complex"></iframe>
                </div>
            </div>
        </div>
    </div>
</div>